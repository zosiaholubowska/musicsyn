Index: musicsyn/balanced_sequence.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pandas\r\nimport numpy as np\r\nimport os\r\n\r\n\"\"\"\r\nWe can use the file of one of the stimuli to test the function\r\n\"\"\"\r\n\"\"\"\r\nfile = (\"stim_maj_2.csv\")\r\nos.chdir('/Users/zofiaholubowska/Documents/PhD/3_experiment/stimuli')\r\n\r\ndef read_melody(file):\r\n    score_data = pandas.read_csv(file, sep=\";\")  # open the csv file with notes\r\n    onsets = score_data.onset_sec.to_list()  # list of onsets of consecutive notes\r\n    frequencies = score_data.freq.to_list()  # frequencies of consecutive notes\r\n    durations = score_data.duration_sec.to_list()  # note durations\r\n    boundaries = score_data.boundary.to_list()  # 0 or 1 indication if the note is the beginning of a new phrase\r\n    changable_notes = score_data.changable_note.to_list() #if at note is possible to change direction\r\n    onsets.append(onsets[-1] + durations[-1] + 0.1)  # I add a dummy note here\r\n    durations.append(0.1)  # I add a dummy note here\r\n    return onsets, frequencies, durations, boundaries, changable_notes\r\n\r\n\r\nonsets, frequencies, durations, boundaries, changable_notes = read_melody(file)\r\n\r\n\"\"\"\r\n\r\ndef balanced_sequence(boundaries, changable_notes, subject, melody_file):\r\n    \"\"\"\r\n    Here we define a df, to which we will append all the sequence values\r\n\r\n    \"\"\"\r\n    boundaries_df = pandas.DataFrame(np.column_stack([boundaries, changable_notes]), columns=['boundary', 'changable_notes'])\r\n    boundaries_df['idx'] = range(len(boundaries_df))\r\n\r\n    n_boundaries = sum(boundaries)  # number of boundaries in stimulus\r\n    n_changable = sum(changable_notes)  # number of changable notes in stimulus\r\n    n_changes = round(0.2 * n_changable)  # 20% of notes has to have a location/cue change\r\n\r\n    #print(n_boundaries, n_changable, n_changes)\r\n\r\n\r\n\r\n    \r\n    #This part is to calculate the sequence for location changes\r\n    temp_arr = np.array([0] * round((0.4 * n_boundaries)) + [1] * round((0.6 * n_boundaries)))\r\n    np.random.shuffle(temp_arr)  # we give 60% chance to location change, when there is a phrase boundary\r\n    seq_boundaries = temp_arr.tolist()\r\n\r\n    n_boundaries_loc = sum(seq_boundaries)\r\n    p_nbound = (n_changes - n_boundaries_loc) / n_changable\r\n\r\n    temp_arr = np.array([0] * round(((1 - p_nbound) * (n_changable - n_boundaries))) + [1] * round((p_nbound) * (n_changable - n_boundaries)))\r\n    np.random.shuffle(temp_arr)  # we give 60% chance to location change, when there is a phrase boundary\r\n    seq_noboundaries = temp_arr.tolist()\r\n\r\n\r\n    no_boundaries = boundaries_df.loc[boundaries_df['boundary'] == 0]\r\n\r\n    #print(len(no_boundaries))\r\n\r\n    changable_no_boundaries = no_boundaries.loc[no_boundaries['changable_notes'] == 1]\r\n\r\n    if len(seq_noboundaries) > len(changable_no_boundaries):\r\n        seq_noboundaries = seq_noboundaries[:len(changable_no_boundaries)]\r\n    elif len(seq_noboundaries) < len(changable_no_boundaries):\r\n        seq_noboundaries += [1] + [0] * (len(changable_no_boundaries) - 1)\r\n\r\n    # Ensure the length is exactly the same\r\n    seq_noboundaries = seq_noboundaries[:len(changable_no_boundaries)]\r\n\r\n    changable_no_boundaries.insert(1, 'sequence', seq_noboundaries)\r\n\r\n    unchangable_no_boundaries = no_boundaries.loc[no_boundaries['changable_notes'] == 0]\r\n    unchangable_no_boundaries['sequence'] = 0\r\n\r\n    sequence = [unchangable_no_boundaries, changable_no_boundaries]  # we append two sequences into one df\r\n    sequence = pandas.concat(sequence)\r\n    temp_no_seq = sequence.sort_values(by='idx', ascending=True)\r\n\r\n\r\n\r\n\r\n    yes_boundaries = boundaries_df.loc[boundaries_df['boundary'] == 1]\r\n\r\n\r\n    if len(seq_boundaries) > len(yes_boundaries):\r\n        seq_boundaries = seq_boundaries[:len(yes_boundaries)]\r\n    elif len(seq_boundaries) < len(yes_boundaries):\r\n        seq_boundaries.append(1)\r\n\r\n    yes_boundaries.insert(1, 'sequence', seq_boundaries)\r\n\r\n\r\n    sequence = [yes_boundaries, temp_no_seq]  # we append two sequences into one df\r\n    sequence = pandas.concat(sequence)\r\n    temp_seq = sequence.sort_values(by='idx', ascending=True)\r\n\r\n\r\n    #This part is to compute the prompt for the response - visual cue\r\n\r\n    yes_boundaries_change = temp_seq.loc[(temp_seq['sequence'] == 1) & (temp_seq['boundary'] == 1)]\r\n\r\n    temp_arr = np.array([0] * round((0.5 * len(yes_boundaries_change))) + [1] * round((0.5 * len(yes_boundaries_change))))\r\n    np.random.shuffle(temp_arr)  # we give 60% chance to location change, when there is a phrase boundary\r\n    seq_boundaries_change_cues = temp_arr.tolist()\r\n\r\n    if len(seq_boundaries_change_cues) > len(yes_boundaries_change):\r\n        seq_boundaries_change_cues = seq_boundaries_change_cues[:len(yes_boundaries_change)]\r\n    yes_boundaries_change.insert(1, 'cue', seq_boundaries_change_cues)\r\n\r\n    yes_boundaries_nochange = yes_boundaries.loc[temp_seq['sequence'] == 0]\r\n\r\n    temp_arr = np.array([0] * round((0.5 * len(yes_boundaries_nochange))) + [1] * round((0.5 * len(yes_boundaries_nochange))))\r\n    np.random.shuffle(temp_arr)  # we give 60% chance to location change, when there is a phrase boundary\r\n    seq_boundaries_nochange_cues = temp_arr.tolist()\r\n\r\n    if len(seq_boundaries_nochange_cues) > len(yes_boundaries_nochange):\r\n        seq_boundaries_nochange_cues = seq_boundaries_nochange_cues[:len(yes_boundaries_nochange)]\r\n    yes_boundaries_nochange.insert(1, 'cue', seq_boundaries_nochange_cues)\r\n\r\n    yes_boundaries = [yes_boundaries_change, yes_boundaries_nochange]  # we append two sequences into one df\r\n    yes_boundaries = pandas.concat(yes_boundaries)\r\n    yes_boundaries = yes_boundaries.sort_values(by='idx', ascending=True)\r\n\r\n    n_boundary_cues = sum(yes_boundaries[\"cue\"])\r\n\r\n    p_nbound_cues = (n_changes - n_boundary_cues) / n_changable\r\n\r\n    no_boundaries_unchangable = temp_seq.loc[(temp_seq['boundary'] == 0) & (temp_seq['changable_notes'] == 0)]\r\n    no_boundaries_unchangable['cue'] = 0\r\n    no_boundaries_changable = temp_seq.loc[(temp_seq['boundary'] == 0) & (temp_seq['changable_notes'] == 1)]\r\n\r\n    no_boundaries_change = no_boundaries_changable.loc[no_boundaries_changable['sequence'] == 1]\r\n\r\n    temp_arr = np.array([0] * round(((1 - p_nbound_cues - 0.5) * len(no_boundaries_change))) + [1] * round(((p_nbound_cues + 0.5) * len(no_boundaries_change))))\r\n    np.random.shuffle(temp_arr)  # we give 60% chance to location change, when there is a phrase boundary\r\n    seq_boundaries_change_cues = temp_arr.tolist()\r\n\r\n    if len(seq_boundaries_change_cues) > len(no_boundaries_change):\r\n        seq_boundaries_change_cues = seq_boundaries_change_cues[:len(no_boundaries_change)]\r\n    no_boundaries_change.insert(1, 'cue', seq_boundaries_change_cues)\r\n\r\n\r\n    no_boundaries_nochange = no_boundaries_changable.loc[no_boundaries_changable['sequence'] == 0]\r\n\r\n    temp_arr = np.array([0] * round(((1 - p_nbound_cues + 0.1) * len(no_boundaries_nochange))) + [1] * round(((p_nbound_cues - 0.1) * len(no_boundaries_nochange))))\r\n    np.random.shuffle(temp_arr)  # we give 60% chance to location change, when there is a phrase boundary\r\n    seq_boundaries_nochange_cues = temp_arr.tolist()\r\n\r\n    if len(seq_boundaries_nochange_cues) > len(no_boundaries_nochange):\r\n        seq_boundaries_nochange_cues = seq_boundaries_nochange_cues[:len(no_boundaries_nochange)]\r\n    no_boundaries_nochange.insert(1, 'cue', seq_boundaries_nochange_cues)\r\n\r\n    no_boundaries = [no_boundaries_change, no_boundaries_nochange]  # we append two sequences into one df\r\n    no_boundaries = pandas.concat(no_boundaries)\r\n    no_boundaries = no_boundaries.sort_values(by='idx', ascending=True)\r\n\r\n    sequence = [no_boundaries, yes_boundaries]  # we append two sequences into one df\r\n    sequence = pandas.concat(sequence)\r\n    semi_final = sequence.sort_values(by='idx', ascending=True)\r\n\r\n    sequence = [semi_final, no_boundaries_unchangable]\r\n    sequence = pandas.concat(sequence)\r\n    final = sequence.sort_values(by='idx', ascending=True)\r\n\r\n    final.to_csv(\r\n        f\"/Users/zofiaholubowska/Documents/PhD/3_experiment/musicsyn/Results/{subject}/{subject}_seq_{melody_file}\",\r\n    )\r\n    #print(final.to_string())\r\n    print(\"Total visual cues:\")\r\n    print(sum(final[\"cue\"]))\r\n    print(\"Total location changes:\")\r\n    print(sum(final[\"sequence\"]))\r\n    print(\"Boundary with change:\")\r\n    print(final[(final['boundary'] == 1) & (final['sequence'] == 1)].shape[0])\r\n    print(final[(final['boundary'] == 1) & (final['sequence'] == 1) & (final['cue'] == 1)].shape[0])\r\n    print(\"Boundary with no change:\")\r\n    print(final[(final['boundary'] == 1) & (final['sequence'] == 0)].shape[0])\r\n    print(final[(final['boundary'] == 1) & (final['sequence'] == 0) & (final['cue'] == 1)].shape[0])\r\n    print(\"No boundary with change:\")\r\n    print(final[(final['boundary'] == 0) & (final['sequence'] == 1)].shape[0])\r\n    print(final[(final['boundary'] == 0) & (final['sequence'] == 1) & (final['cue'] == 1)].shape[0])\r\n    print(\"No boundary with no change:\")\r\n    print(final[(final['boundary'] == 0) & (final['changable_notes'] == 1) & (final['sequence'] == 0)].shape[0])\r\n    print(final[(final['boundary'] == 0) & (final['changable_notes'] == 1) & (final['sequence'] == 0) & (final['cue'] == 1)].shape[0])\r\n    return final\r\n\r\n#balanced_sequence(boundaries, changable_notes, \"FH\", file)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/musicsyn/balanced_sequence.py b/musicsyn/balanced_sequence.py
--- a/musicsyn/balanced_sequence.py	(revision 55854c031d7ab4cf1282af6a4910ef4235fa5ae3)
+++ b/musicsyn/balanced_sequence.py	(date 1698847081576)
@@ -165,7 +165,7 @@
     final = sequence.sort_values(by='idx', ascending=True)
 
     final.to_csv(
-        f"/Users/zofiaholubowska/Documents/PhD/3_experiment/musicsyn/Results/{subject}/{subject}_seq_{melody_file}",
+        os.getcwd() + f"/musicsyn/Results/{subject}/{subject}_seq_{melody_file}",
     )
     #print(final.to_string())
     print("Total visual cues:")
Index: musicsyn/pilot_musicsyn_anotated.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport subprocess\r\nimport itertools\r\nimport pickle\r\nimport numpy\r\nfrom numpy.random import default_rng\r\nimport matplotlib.pyplot as plt\r\nimport pandas\r\nimport slab\r\nfrom musicsyn.balanced_sequence import balanced_sequence\r\nfrom subject_data import subject_data\r\nimport random\r\nimport os\r\n\r\nos.chdir('/Users/zofiaholubowska/Documents/PhD/3_experiment/musicsyn')\r\nplt.ion()  # enable interactive mode - interactive mode will be on, figures will automatically be shown\r\nrandgenerator = default_rng()  # generator of random numbers\r\nils = pickle.load(open(\"ils.pickle\", \"rb\"))  # load interaural level spectrum ???\r\n\r\n\r\ndef read_melody(file):\r\n    \"\"\"\r\n    This function reads a csv file with the description of notes\r\n    - score data (from csv file)\r\n    - note onsets\r\n    - note frequencies\r\n    - note durations\r\n    - if the note is at the phrase boundary\r\n    \"\"\"\r\n    score_data = pandas.read_csv(file, sep=\";\")  # open the csv file with notes\r\n    onsets = score_data.onset_sec.to_list()  # list of onsets of consecutive notes\r\n    frequencies = score_data.freq.to_list()  # frequencies of consecutive notes\r\n    durations = score_data.duration_sec.to_list()  # note durations\r\n    changable_notes = score_data.changable_note.to_list()  # if at note is possible to change direction\r\n    boundaries = (\r\n        score_data.boundary.to_list()\r\n    )  # 0 or 1 indication if the note is the beginning of a new phrase\r\n    return onsets, frequencies, durations, boundaries, changable_notes\r\n\r\n\r\ndef expenv(n_samples):\r\n    \"\"\"\r\n    It is to create more natural sound\r\n    \"\"\"\r\n    t = numpy.linspace(\r\n        start=0, stop=1, num=n_samples\r\n    )  # returns evenly spaced numbers over a specified interval\r\n    return slab.Signal(numpy.exp(-(0.69 * 5) * t))  # what these numbers specify?\r\n\r\n\r\ndef note(f0, duration):\r\n    \"\"\"\r\n    This is to create actual sound\r\n    \"\"\"\r\n    sig = slab.Sound.harmoniccomplex(f0, duration)\r\n    env = expenv(sig.n_samples)\r\n    sig = sig * env\r\n    return slab.Binaural(sig.ramp())\r\n\r\n\r\ndef play(stim):\r\n    \"\"\"\r\n    Plays a created note\r\n    \"\"\"\r\n    stim.write(\"tmp.wav\")\r\n    subprocess.Popen([\"afplay\", \"tmp.wav\"])\r\n\r\ndef run(melody_file, subject):\r\n    file = slab.ResultsFile(\r\n        subject\r\n    )  # here we name the results folder with subject name\r\n    file_name = file.name\r\n\r\n    onsets, frequencies, durations, boundaries, changable_notes = read_melody(f\"/Users/zofiaholubowska/Documents/PhD/3_experiment/stimuli/{melody_file}\")  # reading the csv file with the information about the notes\r\n    seq = balanced_sequence(boundaries, changable_notes, subject, melody_file)\r\n    # depending of number of boundaries, we are creating a sequence\r\n    directions = itertools.cycle(\r\n        [0, 20]\r\n    )  # iterator, which will return the numbers from 0 to 20 in a infinite loop\r\n    # but this iterator does only 0 and 20, shouldn't we have -20, as well?\r\n    direction_jitter = 5\r\n    start_time = time.time()  # creates a timestamp in Unix format\r\n    # setup the figure for button capture\r\n    fig = plt.figure(\"stairs\")  # I cannot see the figure - for check later\r\n\r\n    def on_key(event):\r\n        print(\"write key: \", event.key)\r\n        file.write(\r\n            event.key, tag=f\"{time.time() - start_time:.3f}\"\r\n        )  # logs the key that was pressed on a specified time\r\n\r\n    cid = fig.canvas.mpl_connect(\"key_press_event\", on_key)\r\n    onsets.append(\r\n        onsets[-1] + durations[-1] + 0.1\r\n    )  # add a dummy onset so that the if statement below works during the last note\r\n    # durations.append(0.1)  ###\r\n    i = 0\r\n    direction = next(directions)\r\n    try:\r\n        while time.time() - start_time < onsets[-1] + durations[-1]:\r\n            if time.time() - start_time > onsets[i]:  # play the next note\r\n                #print(i)\r\n                stim = note(frequencies[i], durations[i])\r\n                if seq[\"sequence\"][i] == 1:\r\n                    direction = next(directions)  # toggle direction\r\n                    print(\"direction change\")\r\n                if seq[\"boundary\"][i]:  # so if there is 1 in the boundaries list\r\n                    print(\"at boundary!\")\r\n                if seq[\"cue\"][i] == 1:\r\n                    print(\"########\")\r\n                    print(\"########\")\r\n                    print(\"visual cue!\")\r\n                    print(\"########\")\r\n                    print(\"########\")\r\n                direction_addon = randgenerator.uniform(low=-direction_jitter / 2, high=direction_jitter / 2)\r\n                # it creates jitter for the change of the location ranging from -2,5 to 2,5\r\n                #print(direction + direction_addon)\r\n                stim = stim.at_azimuth(\r\n                    direction + direction_addon, ils\r\n                )  # this matches the azimuth with the ils values\r\n                stim = (\r\n                    stim.externalize()\r\n                )  # smooths the sound with HRTF, to simulate external sound source\r\n                file.write(frequencies[i], tag=f\"{time.time() - start_time:.3f}\")\r\n                play(stim)\r\n                i += 1\r\n            plt.pause(0.01)\r\n    except IndexError:\r\n        subject_data(subject, file, melody_file)\r\n\r\n\r\ndef select_file():\r\n    files = [\"stim_maj_1.csv\", \"stim_maj_2.csv\", \"stim_maj_3.csv\"]\r\n    random.shuffle(files)\r\n\r\n    for file in files:\r\n        print(file)\r\n        run(file, 'FH')\r\n\r\n        user_input = input(\"Do you want to continue? (y/n): \")\r\n        if user_input.lower() == 'n':\r\n            break\r\n        elif user_input.lower() == 'y':\r\n            print(\"Continuing...\")\r\n\r\nif __name__ == \"__main__\":\r\n    select_file()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/musicsyn/pilot_musicsyn_anotated.py b/musicsyn/pilot_musicsyn_anotated.py
--- a/musicsyn/pilot_musicsyn_anotated.py	(revision 55854c031d7ab4cf1282af6a4910ef4235fa5ae3)
+++ b/musicsyn/pilot_musicsyn_anotated.py	(date 1698846902826)
@@ -8,14 +8,15 @@
 import pandas
 import slab
 from musicsyn.balanced_sequence import balanced_sequence
-from subject_data import subject_data
+from musicsyn.subject_data import subject_data
 import random
 import os
 
-os.chdir('/Users/zofiaholubowska/Documents/PhD/3_experiment/musicsyn')
+os.chdir('C:/projects/musicsyn')
 plt.ion()  # enable interactive mode - interactive mode will be on, figures will automatically be shown
 randgenerator = default_rng()  # generator of random numbers
-ils = pickle.load(open("ils.pickle", "rb"))  # load interaural level spectrum ???
+
+ils = pickle.load(open(os.getcwd() + "/musicsyn/ils.pickle", "rb"))  # load interaural level spectrum ???
 
 
 def read_melody(file):
@@ -71,7 +72,7 @@
     )  # here we name the results folder with subject name
     file_name = file.name
 
-    onsets, frequencies, durations, boundaries, changable_notes = read_melody(f"/Users/zofiaholubowska/Documents/PhD/3_experiment/stimuli/{melody_file}")  # reading the csv file with the information about the notes
+    onsets, frequencies, durations, boundaries, changable_notes = read_melody(os.getcwd() + f"/stimuli/{melody_file}")  # reading the csv file with the information about the notes
     seq = balanced_sequence(boundaries, changable_notes, subject, melody_file)
     # depending of number of boundaries, we are creating a sequence
     directions = itertools.cycle(
